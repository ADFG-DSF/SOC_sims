---
title: "SOC_methods"
author: "Adam Reimer"
format:
  html:
    embed-resources: true
editor: visual
---

```{r include = FALSE}
packs <- c("tidyverse", "ggforce", "RcppRoll", "knitr")
lapply(packs, require, character.only = TRUE)

# source functions
function_files <- list.files(path="..\\functions")
lapply(function_files, function(x) source(paste0("..\\functions\\", x)))

vec_lnalpha <- seq(1, 2, length.out = 3)
vec_sigW <- seq(0.25, 0.75, length.out = 3)
vec_phi <- seq(0, .7, length.out = 3)
beta <- 0.0001
df_power <- data.frame(lnalpha = vec_lnalpha,
                       power = c(0.6, 0.7, 0.8)) #how to pick these. High for SOC sims. Should be lower for OPY sims.
input <- 
  expand.grid(lnalpha = vec_lnalpha, sigW = vec_sigW, phi = vec_phi) %>%
  mutate(beta = beta, 
         Smsy = get_Smsy(lnalpha, beta, TRUE, sigma = sigW, phi = phi),
         lb_eggers = Smsy * 0.8, #Egger bounds
         ub_eggers = Smsy * 1.6) %>%
  rowwise() %>%
  mutate(lb_pctMSY = optimise(get_bounds, #'true' OYP bounds
                              1:Smsy, 
                              lnalpha = lnalpha, 
                              beta = beta,
                              pct_MSY = 0.9,
                              correct = TRUE,
                              sigma = sigW,
                              phi = phi)$minimum,
          ub_pctMSY = optimise(get_bounds, 
                              Smsy:(Smsy*5), 
                              lnalpha = lnalpha, 
                              beta = beta,
                              pct_MSY = 0.7,
                              correct = TRUE,
                              sigma = sigW,
                              phi = phi)$minimum) %>%
  ungroup() %>%
  left_join(df_power, by = "lnalpha")

Chinook_age <- c('3' = 0.1, '4' = 0.2, '5' = 0.3, '6' = 0.38, '7' = 0.02)

input_sims = 5000


# Simulation params -------------------------------------------------------
Ricker_plots <- list()
for(i in 1:length(unique(input$lnalpha))){
Ricker_plots[[i]] <- 
  input %>% 
    slice(rep(1:n(), each = 251)) %>% 
    mutate(S = rep(seq(0, 5 * 1 / max(beta), by = 200), times = nrow(input)),
           R = Ricker(lnalpha = get_lnalpha_p(lnalpha, beta, sigW, phi), beta = beta, S = S),
           Rmsy = Ricker(get_lnalpha_p(lnalpha, beta, sigW, phi), beta, Smsy),
           Smax = 1 / beta,
           Rmax = Ricker(lnalpha = get_lnalpha_p(lnalpha, beta, sigW, phi), beta = beta, S = Smax)) %>%
    ggplot(aes(x = S, y = R)) +
      geom_rect(aes(xmin = lb_pctMSY, xmax = ub_pctMSY, ymin = -Inf, ymax = Inf), fill = "grey95") +
      geom_line() +
      geom_abline(intercept = 0, slope = 1, linetype = 2) +
      geom_point(aes(x = Smax, y = Rmax)) +
      geom_segment(aes(x = Smsy, xend = Smsy, y = Smsy, yend = Rmsy), linetype = 3) +
      theme_bw() +
      facet_grid_paginate(paste0("\u03C6: ", phi) ~ paste0("ln(\u03B1): ", lnalpha) + paste0("\u03C3: ", sigW), 
                          #scales = "free_y",
                          ncol = 3, nrow = 3, page = i)
}
```

## Methods

Herein we used simulation to explore the behavior of the Sustainable Salmon Policy's stock of concern designations under alternative ocean productivity regimes. These simulations are intended to inform expectations regarding stock of concern designations and help standardize the Department decision making process wrt soc designations.

### Stock Recruit Process

Abundance of salmon is generated by a S-R relationship that describes the number of fish expected to return (the "recruitment") from a given number of spawning fish (the "escapement"). The total expected recruitment $R_{c}$ produced from fish spawning in brood year $c$ follows the Ricker formulation:

$$
R_{c}~=~S_{c}\alpha \textrm{exp}(-\beta S_{c})
$$

where $S_{c}$ is the number of spawners, $\alpha$ (number of recruits per spawner in the absence of density dependence) is a measure of productivity, and $\beta$ is a measure of density dependence.

However, productivity varies among brood years, fluctuating around a central tendency. Time-varying productivity often manifests as serially correlated model residuals, so a lognormal error term with a lag of 1 year was included in the linearized form of the S-R relationship to represent realized recruitment.

$$
\textrm{ln}(R_{c})~=~\textrm{ln}(S_{c})+\textrm{ln}(\alpha)-\beta S_{c} +\phi \nu_{(c-1)}+\epsilon_{W}
$$

where $\phi$ is the lag-1 serial correlation coefficient, $\nu_{c}$ are model residuals defined as

$$
\nu_{c}~=~\textrm{ln}(R_{c})-\textrm{ln}(S_{c})-\textrm{ln}(\alpha)+\beta S_{c}
$$

and the $\epsilon_{W}$ are independently and normally distributed process errors with "white noise" variance $\sigma^2_{W}$.

Age at maturity ($p_{ca}$), which is needed to distribute recruitment across calendar years, is treated as a constant within each brood year. The abundance $N_{ya}$ of age $a$ salmon in calendar year $y$ is the product of the age at maturity scalar and the total return (recruitment) $R_{c}$ for from brood year $c=yâˆ’a$:

$$
N_{ya}~=~p_{(y-a)a}R_{(y-a)}
$$

Total run $N_{y}$ during calendar year $y$ is the sum of abundance at age across all ages:

$$
N_{y}~=~\sum_{a} N_{ya}
$$

Instantaneous fishing mortality $F_{y}=-log(1-U_y)$ is a function of the annual harvest rate $U_y$ and used to calculate escapement $S_y$:

$$
S_{y}~=~N_y*F_y
$$

Where $N_y^{obs}=N_y \textrm{exp}(\epsilon_N)$ with $\epsilon_{N}~\sim~\textrm{Normal}(0, \sigma^2_{N})$ and

### Harvest process

The annual harvest rate $U_{y}$, was modeled as a function of the observed total run $N_{y}^{obs}$, both bounds of the escapement goal $lb$ and $ub$, and the power of the fishery.

$$
U_{y}~=~\textrm{f}(N_y^{obs}, lb, ub, power)
$$

Where $N_y^{obs}=N_y \textrm{exp}(\epsilon_N)$ with $\epsilon_{N}~\sim~\textrm{Normal}(0, \sigma^2_{N})$. To determine the annual harvest rates we might expect under escapement goal management the following algorithm was used:

$$
U_y^{goal} = \textrm{minimum}(\textrm{Uniform}(U_{ub}, U_{lb}), power)
$$

where

$$
U_{lb} = \textrm{if}(N_Y^{obs} > lb)~\frac{N_y^{obs} - lb}{N_y^{obs}}~\textrm{else}~0
$$

$$
U_{ub} = \textrm{if}(N_Y^{obs} > ub)~\frac{N_y^{obs} - ub}{N_y^{obs}}~\textrm{else}~0
$$

and $power$ represent the maximum harvest rate the fishery is capable of producing.

### Simulation Parameters

Simulations were run with 27 parameter combinations $\alpha = (1.0, 1.5, 2.0)$, $\sigma = (0.25, 0.50, 0.75)$, and $\phi = (0.00, 0.35, 0.70)$. $\beta=0.0001$ and $p_a=(0.10, 0.20, 0.30, 0.38, 0.02)$ were for all simulations while lower bound of the escapement goal was the escapement that predicted a mean return which produced 90% of MSY while the upper bound was was the escapement that predicted a mean return which produced 70% of MSY. The mean Ricker curve, MSY, S_max, and escapement goals are plotted below for all parameter combinations.

```{r, echo = FALSE, fig.height=8, fig.width=8}
Ricker_plots[[1]] + coord_cartesian(xlim = c(0, 20000), ylim = c(0, 20000))
Ricker_plots[[2]] + coord_cartesian(xlim = c(0, 30000), ylim = c(0, 30000))
Ricker_plots[[3]] + coord_cartesian(xlim = c(0, 50000), ylim = c(0, 50000))
```

```{r include = FALSE}
sim_base <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0,
                         sigF = 0,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)


# * Plot time series --------------------------------------------------------
#writing function here since it has dubious use outside of this single application
plot_ts <- function(dat, lnalpha0){ 
  df <- 
    dat %>%
    select(lnalpha, sigW, phi, sim, lb_goal, ub_goal, S, N) %>%
    filter(lnalpha == lnalpha0) %>%
    pivot_longer(c(S, N), names_to = "stat", values_to = "value")
  
  limit <- quantile(df$value[df$stat == "N"], .98, na.rm = TRUE)
  
      ggplot(df, aes(x = sim, y = value, color = stat)) +
        geom_line(alpha = 0.4) +
        geom_hline(aes(yintercept = lb_goal), linetype = 2) +
        geom_hline(aes(yintercept = ub_goal), linetype = 2) +
        scale_y_continuous(limits = c(0, limit)) +
        scale_x_continuous(name = "Simulation year") +
        facet_grid(paste0("\u03C6: ", phi) ~ paste0("\u03C3: ", sigW)) +
        ggtitle(label = bquote(log(alpha): .(lnalpha0)))
}

```

Examining a time series of simulation results can help us understand an intuitive sense of the model. Because of the color scheme used (pink for total run and teal for escapement) grey areas represent simulations when there was minimal harvestable surplus. Notice that with modest process error ($\sigma=0.35$) and autocorrelation ($\phi=0$) the fishery is predictable and results in consistent harvestable surplus. As process error increases we see more variability in total run including instances of very large runs for which the fishery had insufficient power to harvest within the goal range and instances of smaller runs for which little or no harvestable surplus was available. Autocorelation also increases variability in total run (resulting in similar patters) as well as makes the large or small run sizes more persistent. Looking across these 3 panels we see similar patterns for all values of log($\alpha$) although larger values resulting in larger run sizes are more harvestable surplus.

```{r echo = FALSE, warning = FALSE, fig.height=8, fig.width=8}
# because of the colors used teal below the lower bound represents times we fished below the lower bound w abundant fish... call the a yield concern
# while grey below the lower bound represent when the fish were not there to make the goal ... call that a management concern
# When N is far below the lb it is a conservation concern 

plot_ts(sim_base, 1)
plot_ts(sim_base, 1.5) #+ coord_cartesian(xlim = c(500, 600))
plot_ts(sim_base, 2)
```

Note that the simulations above were run with zero estimation error ($\sigma_N=0$) and no implementation error ($\sigma_F=0$). Increasing estimation error to $\sigma_N=0.3$ (shown below for $\textrm{log}(\alpha) = 1.5$) primarily increases the likelihood of over-escapement.

```{r echo = FALSE, warning = FALSE, fig.height=8, fig.width=8}
sim_baseN3 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0.3,
                         sigF = 0,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

plot_ts(sim_baseN3, 1.5)
```

Increasing implementation error to $\sigma_F=0.3$ (shown below for $\textrm{log}(\alpha) = 1.5$) increases the likelihood of both under- and over-escapement.

```{r echo = FALSE, warning = FALSE, fig.height=8, fig.width=8}
sim_baseF3 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0,
                         sigF = 0.3,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

plot_ts(sim_baseF3, 1.5)
```

```{r include = FALSE}
#demonstrate behavior of sigN and sigF
sim_baseF15 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0,
                         sigF = 0.15,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

sim_baseN15 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0.15,
                         sigF = 0,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

sim_baseF15N15 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0.15,
                         sigF = 0.15,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

sim_baseF3N3 <- 
  mapply(FUN = simSR_goal,
         lnalpha = input$lnalpha,
         sigW = input$sigW,
         phi = input$phi,
         lb_goal = input$lb_pctMSY,
         ub_goal = input$ub_pctMSY,
         power = input$power,
         MoreArgs = list(beta = beta,
                         age0 = Chinook_age,
                         Sims0 = 1500,
                         sigN = 0.3,
                         sigF = 0.3,
                         Hfun = H_goal),
         SIMPLIFY = FALSE) %>%
  do.call("rbind", .)

temp <-
  rbind(sim_base, sim_baseF15) %>%
  rbind(sim_baseN15) %>%
  rbind(sim_baseN3) %>%
  rbind(sim_baseF3) %>%
  rbind(sim_baseF15N15) %>%
  rbind(sim_baseF3N3) %>%
  group_by(lnalpha, sigW, phi, sigN, sigF) %>%
  # mutate(eg_range = ifelse(S < lb_goal, "under", 
  #                          ifelse(S > ub_goal, "over", "within")))
  summarize(under = mean(S < lb_goal),
            over = mean(S > ub_goal),
            within = mean(S >= lb_goal & S <= ub_goal)) %>%
  pivot_longer(cols = c(under, over, within),
               names_to = "eg_range",
               values_to = "pct")
```

When $\sigma_F$ is varied between 0 and 0.3 we see an increasing percentage of under-escapements as $\sigma_F$ increases although the pattern is blurred by variability in the SR relationship at high levels of $\sigma$ or $\phi$.

```{r fig.caption = "Percent of years under the escapemnt goal"}
temp %>%
  filter(sigF %in% c(0, 0.15, 0.3) & sigN == 0) %>%
  filter(eg_range == "under") %>%
  ggplot(aes(x = as.character(lnalpha), y = pct, group = sigF, fill = as.character(sigF))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_alpha_manual(values = c(1, 0.5)) +
  facet_grid(paste0("\u03C6: ", phi) ~ paste0("\u03C3: ", sigW))
```

With respect to over-escapement, when $\sigma_F$ is varied between 0 and 0.3 there are increases as both $\sigma_F$ and $\textrm{log}(\alpha)$ increase with the same masking by variability in the SR relationship at high levels of $\sigma$ or $\phi$.

```{r}
temp %>%
  filter(sigF %in% c(0, 0.15, 0.3) & sigN == 0) %>%
  filter(eg_range == "over") %>%
  ggplot(aes(x = as.character(lnalpha), y = pct, group = sigF, fill = as.character(sigF))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(paste0("\u03C6: ", phi) ~ paste0("\u03C3: ", sigW))
```

When $\sigma_N$ is varied between 0 and 0.3 we see negligible effects on the percentage of under-escapements as $\sigma_N$ increases.

```{r}
temp %>%
  filter(sigN %in% c(0, 0.15, 0.3) & sigF == 0) %>%
  filter(eg_range == "under") %>%
  ggplot(aes(x = as.character(lnalpha), y = pct, group = sigN, fill = as.character(sigN))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(paste0("\u03C6: ", phi) ~ paste0("\u03C3: ", sigW))
```

With respect to over-escapement, when $\sigma_N$ is varied between 0 and 0.3 there are increases as both $\sigma_N$ and $\textrm{log}(\alpha)$ increase with the same masking by variability in the SR relationship at high levels of $\sigma$ or $\phi$.

```{r}
temp %>%
  filter(sigN %in% c(0, 0.15, 0.3) & sigF == 0) %>%
  filter(eg_range == "over") %>%
  ggplot(aes(x = as.character(lnalpha), y = pct, group = sigN, fill = as.character(sigN))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(paste0("\u03C6: ", phi) ~ paste0("\u03C3: ", sigW))
```
